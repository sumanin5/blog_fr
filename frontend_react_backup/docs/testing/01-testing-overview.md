# 前端测试概述：目的、原理与原则

## 1. 为什么需要前端测试？

### 1.1 测试的核心目的

前端测试的根本目的是：**确保应用在用户视角下的行为符合预期，并在代码变更时快速发现问题**。

具体来说，测试帮助我们：

| 目标         | 说明                                                 |
| ------------ | ---------------------------------------------------- |
| **防止回归** | 修改代码时，确保原有功能没有被破坏                   |
| **提升信心** | 有测试覆盖的代码，改起来更放心                       |
| **活的文档** | 测试用例描述了组件应该如何工作，是最好的"使用说明书" |
| **驱动设计** | 写测试时会思考组件的 API 是否合理，反过来改进设计    |
| **协作沟通** | 测试用例清晰表达需求，减少团队成员间的理解偏差       |

### 1.2 前端测试的独特挑战

前端比后端更难测试，因为它涉及：

- **UI 渲染**：组件是否正确显示？
- **用户交互**：点击、输入、拖拽是否正常响应？
- **异步操作**：API 请求、动画、定时器如何处理？
- **浏览器环境**：不同浏览器行为是否一致？
- **状态管理**：复杂的状态流转是否正确？

---

## 2. 测试的基本原理

### 2.1 测试的本质：输入 → 输出 → 断言

所有测试都遵循一个核心模式：

```
给定某个输入 → 执行某个操作 → 验证输出是否符合预期
```

在前端测试中：

| 测试类型 | 输入                   | 操作             | 输出               |
| -------- | ---------------------- | ---------------- | ------------------ |
| 单元测试 | 函数参数               | 调用函数         | 返回值             |
| 组件测试 | Props                  | 渲染组件         | DOM 结构           |
| 集成测试 | 用户操作（点击、输入） | 模拟交互         | UI 变化、回调触发  |
| E2E 测试 | 页面 URL               | 模拟完整用户流程 | 页面状态、网络请求 |

### 2.2 测试金字塔 vs 测试奖杯

#### 传统测试金字塔

```
        ▲
       /E2E\            少量，慢，昂贵
      /-----\
     /集成测试\          适量，中速
    /----------\
   /  单元测试  \        大量，快，便宜
  /--------------\
```

**问题**：前端单元测试（测试纯函数）价值有限，因为大部分代码是 UI 逻辑。

#### Kent C. Dodds 的测试奖杯（更适合前端）

```
       ___________
      /   E2E    \       少量：关键业务流程
     /____________\
    |              |
    |   集成测试    |     ← 重点！大部分测试在这里
    |______________|
    |  静态分析    |      TypeScript + ESLint
    |______________|
```

**核心理念**：

> **"你的测试越接近用户使用软件的方式，它就能给你越多的信心。"**
>
> — Kent C. Dodds (React Testing Library 作者)

---

## 3. 前端测试的核心原则

### 3.1 测试用户行为，而非实现细节

❌ **错误做法**：测试组件内部状态、私有方法、CSS 类名

```tsx
// 不好：测试实现细节
expect(component.state.isOpen).toBe(true);
expect(wrapper.find(".dropdown-open")).toExist();
```

✅ **正确做法**：测试用户能看到、能操作的东西

```tsx
// 好：测试用户行为
await user.click(screen.getByRole("button", { name: "打开菜单" }));
expect(screen.getByRole("menu")).toBeVisible();
```

**为什么**：实现会变，但用户期望不变。测试行为让你重构代码时不用改测试。

### 3.2 优先使用语义化查询

React Testing Library 提供多种查询方法，**优先级从高到低**：

| 优先级 | 方法                   | 适用场景                             |
| ------ | ---------------------- | ------------------------------------ |
| 1      | `getByRole`            | **首选**！查找按钮、链接、表单元素等 |
| 2      | `getByLabelText`       | 表单输入框（通过 label 查找）        |
| 3      | `getByPlaceholderText` | 输入框（当没有 label 时）            |
| 4      | `getByText`            | 非交互元素的文本内容                 |
| 5      | `getByDisplayValue`    | 当前输入框的值                       |
| 6      | `getByAltText`         | 图片（通过 alt 属性）                |
| 7      | `getByTitle`           | title 属性                           |
| 8      | `getByTestId`          | **最后手段**！当其他方法都不可用时   |

**为什么优先用 `getByRole`**：它基于可访问性树（Accessibility Tree），如果这个查询失败，说明你的组件可能也对屏幕阅读器不友好。

### 3.3 避免测试第三方库

不要测试 React、React Router、Axios 等库的功能，它们已经被测试过了。只测试**你的代码**如何使用它们。

### 3.4 每个测试只验证一件事

```tsx
// 不好：一个测试验证太多
test("表单功能", async () => {
  // ... 验证渲染
  // ... 验证输入
  // ... 验证提交
  // ... 验证成功消息
  // ... 验证重定向
});

// 好：拆分成多个聚焦的测试
test("应该显示表单输入框", () => {
  /* ... */
});
test("提交成功后应该显示成功消息", async () => {
  /* ... */
});
test("提交失败后应该显示错误提示", async () => {
  /* ... */
});
```

### 3.5 使用 AAA 模式组织测试

```tsx
test("点击按钮应该增加计数", async () => {
  // Arrange（准备）: 设置测试环境
  render(<Counter initialCount={0} />);
  const user = userEvent.setup();

  // Act（执行）: 执行用户操作
  await user.click(screen.getByRole("button", { name: "+" }));

  // Assert（断言）: 验证结果
  expect(screen.getByText("Count: 1")).toBeInTheDocument();
});
```

### 3.6 异步测试使用正确的等待方法

```tsx
// ❌ 不要使用随意的延时
await new Promise((resolve) => setTimeout(resolve, 1000));

// ✅ 使用 findBy（自动等待元素出现）
const successMessage = await screen.findByText("保存成功");

// ✅ 使用 waitFor（等待断言通过）
await waitFor(() => {
  expect(screen.getByText("保存成功")).toBeInTheDocument();
});
```

---

## 4. 测试策略建议

### 4.1 什么值得测试？（高 ROI）

- ✅ **核心业务逻辑**：登录、注册、支付、文章发布
- ✅ **复杂的条件渲染**：不同状态下显示不同 UI
- ✅ **表单**：验证、提交、错误处理
- ✅ **公共组件**：被多处复用的组件
- ✅ **复杂的自定义 Hook**

### 4.2 什么不值得测试？（低 ROI）

- ❌ **纯展示组件**：只接收 props 并渲染，没有逻辑
- ❌ **第三方库的行为**
- ❌ **CSS 样式细节**
- ❌ **实现细节**（组件内部状态）

### 4.3 测试覆盖率的正确理解

> **覆盖率是副产品，不是目标。**

- 追求高覆盖率容易导致写出脆弱、低价值的测试
- 80% 有意义的覆盖率 > 100% 水分覆盖率
- 关注**关键路径**的覆盖，而非数字

---

## 5. 总结

| 原则             | 要点                                            |
| ---------------- | ----------------------------------------------- |
| 测试用户行为     | 关注用户能看到、能操作的内容                    |
| 优先语义查询     | `getByRole` > `getByText` > `getByTestId`       |
| 集成测试为主     | 测试奖杯模型，大部分测试是集成测试              |
| 测试有意义的场景 | 核心业务 > 公共组件 > 边缘情况                  |
| 保持测试简单     | 每个测试只验证一件事，使用 AAA 模式             |
| 正确处理异步     | 使用 `findBy` 或 `waitFor`，不要用 `setTimeout` |

下一篇：[前端测试框架介绍](./02-testing-frameworks.md)
