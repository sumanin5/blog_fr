# React 组件传递模式 - 可视化图解

## 核心概念：谁负责渲染？

### 场景 1：直接调用

```
┌─────────────────────────────────────┐
│  Parent Component                   │
│  ┌───────────────────────────────┐  │
│  │ function Parent() {           │  │
│  │   return (                    │  │
│  │     <div>                     │  │
│  │       <Child />  ← 直接调用   │  │
│  │     </div>                    │  │
│  │   );                          │  │
│  │ }                             │  │
│  └───────────────────────────────┘  │
│                                     │
│  渲染流程：                          │
│  1. Parent 开始渲染                 │
│  2. 遇到 <Child />                  │
│  3. Parent 调用 Child() 函数        │
│  4. Child 返回 JSX                  │
│  5. Parent 把结果插入 DOM           │
│                                     │
│  特点：                             │
│  ✓ Parent 控制 Child 的渲染         │
│  ✗ Parent 更新时 Child 也会更新     │
└─────────────────────────────────────┘
```

### 场景 2：插槽传递

```
┌─────────────────────────────────────┐
│  App Component (外部)                │
│  ┌───────────────────────────────┐  │
│  │ function App() {              │  │
│  │   return (                    │  │
│  │     <Parent>                  │  │
│  │       <Child />  ← 外部调用   │  │
│  │     </Parent>                 │  │
│  │   );                          │  │
│  │ }                             │  │
│  └───────────────────────────────┘  │
│           ↓                         │
│  ┌───────────────────────────────┐  │
│  │ Parent Component              │  │
│  │ function Parent({ children }) │  │
│  │   return (                    │  │
│  │     <div>                     │  │
│  │       {children}  ← 只是展示  │  │
│  │     </div>                    │  │
│  │   );                          │  │
│  │ }                             │  │
│  └───────────────────────────────┘  │
│                                     │
│  渲染流程：                          │
│  1. App 开始渲染                    │
│  2. App 遇到 <Child />              │
│  3. App 调用 Child() 函数           │
│  4. Child 返回 JSX                  │
│  5. App 把结果作为 children 传给    │
│     Parent                          │
│  6. Parent 只是展示 children        │
│                                     │
│  特点：                             │
│  ✓ App 控制 Child 的渲染            │
│  ✓ Parent 更新时 Child 不会更新     │
│  ✓ 性能更好                         │
└─────────────────────────────────────┘
```

## 传递组件的 6 种方式

### 方式 1：children prop

```tsx
<Container>
  <Header />
  <Content />
</Container>

// 等价于
<Container children={<><Header /><Content /></>} />
```

```
┌──────────────────────┐
│   Container          │
│  ┌────────────────┐  │
│  │ Header         │  │
│  └────────────────┘  │
│  ┌────────────────┐  │
│  │ Content        │  │
│  └────────────────┘  │
└──────────────────────┘
```

### 方式 2：具名插槽

```tsx
<Layout header={<Header />} sidebar={<Sidebar />} content={<Content />} />
```

```
┌─────────────────────────────────┐
│  Layout                         │
│  ┌───────────────────────────┐  │
│  │ header slot               │  │
│  │ <Header />                │  │
│  └───────────────────────────┘  │
│  ┌──────┐  ┌─────────────────┐  │
│  │sidebar│  │ content slot    │  │
│  │<Side>│  │ <Content />     │  │
│  │bar/>│  │                 │  │
│  └──────┘  └─────────────────┘  │
└─────────────────────────────────┘
```

### 方式 3：Render Props

```tsx
<DataFetcher
  render={(data, loading) => (loading ? <Spinner /> : <Display data={data} />)}
/>
```

```
┌─────────────────────────────────┐
│  DataFetcher                    │
│  ┌───────────────────────────┐  │
│  │ 1. 获取数据               │  │
│  │ 2. 管理加载状态           │  │
│  │ 3. 调用 render 函数       │  │
│  │ 4. 传递 data 和 loading   │  │
│  └───────────────────────────┘  │
│           ↓                     │
│  ┌───────────────────────────┐  │
│  │ render(data, loading)     │  │
│  │   ↓                       │  │
│  │ loading ? <Spinner />     │  │
│  │         : <Display />     │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

### 方式 4：函数作为 Children

```tsx
<MouseTracker>
  {({ x, y }) => (
    <div>
      位置: {x}, {y}
    </div>
  )}
</MouseTracker>
```

```
┌─────────────────────────────────┐
│  MouseTracker                   │
│  ┌───────────────────────────┐  │
│  │ 1. 监听鼠标移动           │  │
│  │ 2. 更新 position 状态     │  │
│  │ 3. 调用 children 函数     │  │
│  │ 4. 传递 { x, y }          │  │
│  └───────────────────────────┘  │
│           ↓                     │
│  ┌───────────────────────────┐  │
│  │ children({ x, y })        │  │
│  │   ↓                       │  │
│  │ <div>位置: {x}, {y}</div> │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

### 方式 5：组件作为 Props

```tsx
<Button icon={SaveIcon} label="保存" />
```

```
┌─────────────────────────────────┐
│  Button                         │
│  ┌───────────────────────────┐  │
│  │ function Button({         │  │
│  │   icon: Icon,  ← 组件类型 │  │
│  │   label                   │  │
│  │ }) {                      │  │
│  │   return (                │  │
│  │     <button>              │  │
│  │       <Icon />  ← 渲染    │  │
│  │       {label}             │  │
│  │     </button>             │  │
│  │   );                      │  │
│  │ }                         │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

### 方式 6：React.cloneElement

```tsx
<Wrapper>
  <button>Click</button>
</Wrapper>;

// Wrapper 内部
React.cloneElement(children, {
  className: "injected",
  onClick: handler,
});
```

```
┌─────────────────────────────────┐
│  Wrapper                        │
│  ┌───────────────────────────┐  │
│  │ 原始 children:            │  │
│  │ <button>Click</button>    │  │
│  └───────────────────────────┘  │
│           ↓ cloneElement        │
│  ┌───────────────────────────┐  │
│  │ 克隆后的 children:        │  │
│  │ <button                   │  │
│  │   className="injected"    │  │
│  │   onClick={handler}       │  │
│  │ >                         │  │
│  │   Click                   │  │
│  │ </button>                 │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

## 性能对比

### 直接调用 - 性能问题

```
Parent 状态变化
    ↓
Parent 重新渲染
    ↓
调用 <Child />
    ↓
Child 重新渲染  ← 即使 Child 没有变化！
    ↓
浪费性能
```

### 插槽传递 - 性能优化

```
Parent 状态变化
    ↓
Parent 重新渲染
    ↓
使用 {children}
    ↓
Child 不重新渲染  ← children 是预渲染的！
    ↓
性能更好
```

## Next.js 中的应用

### 服务端组件 + 客户端组件

```
┌─────────────────────────────────────────┐
│  服务器端                                │
│  ┌───────────────────────────────────┐  │
│  │ 1. 渲染 Page (服务端组件)         │  │
│  │    ↓                              │  │
│  │ 2. 生成 HTML                      │  │
│  │    ↓                              │  │
│  │ 3. 把 HTML 作为 children 传给     │  │
│  │    Layout                         │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
                ↓ 发送 HTML
┌─────────────────────────────────────────┐
│  浏览器端                                │
│  ┌───────────────────────────────────┐  │
│  │ 1. 接收 HTML，立即显示            │  │
│  │    ↓                              │  │
│  │ 2. 加载 JavaScript                │  │
│  │    ↓                              │  │
│  │ 3. 激活 Provider (客户端组件)     │  │
│  │    ↓                              │  │
│  │ 4. children (HTML) 不需要重新渲染 │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 代码示例

```tsx
// layout.tsx (服务端组件)
export default function Layout({ children }) {
  return (
    <html>
      <body>
        <ThemeProvider>
          {" "}
          {/* 客户端组件 */}
          {children} {/* 服务端渲染的页面 */}
        </ThemeProvider>
      </body>
    </html>
  );
}

// page.tsx (服务端组件)
export default async function Page() {
  const data = await fetchData(); // 在服务器获取数据
  return <div>{data}</div>;
}
```

```
执行流程：

服务器：
┌──────────────────────────┐
│ 1. 渲染 Page             │
│    ↓                     │
│ 2. fetchData() 在服务器  │
│    ↓                     │
│ 3. 生成 HTML:            │
│    <div>数据内容</div>   │
│    ↓                     │
│ 4. 传给 Layout 的        │
│    children              │
└──────────────────────────┘
         ↓
浏览器：
┌──────────────────────────┐
│ 5. 显示 HTML (快速首屏)  │
│    ↓                     │
│ 6. 激活 ThemeProvider    │
│    (客户端组件)          │
│    ↓                     │
│ 7. children 不需要       │
│    重新渲染              │
└──────────────────────────┘
```

## 决策树：选择哪种方式？

```
需要传递组件？
    ↓
    ├─ 是否需要传递数据给子组件？
    │   ├─ 是 → Render Props 或 Function as Children
    │   └─ 否 → 继续
    │
    ├─ 是否有多个明确的插槽位置？
    │   ├─ 是 → 具名插槽 (Named Slots)
    │   └─ 否 → 继续
    │
    ├─ 是否需要修改子组件的 props？
    │   ├─ 是 → React.cloneElement
    │   └─ 否 → 继续
    │
    ├─ 是否需要传递组件类型（不是实例）？
    │   ├─ 是 → 组件作为 Props
    │   └─ 否 → 继续
    │
    └─ 默认使用 children prop
```

## 记忆技巧

### 口诀

```
直接调用像雇员，父组件是老板
插槽传递像外包，各自独立干

直接调用紧耦合，一荣俱荣一损俱损
插槽传递松耦合，你变你的我不变

直接调用适合简单场景
插槽传递适合复杂内容

Next.js 的秘密：
服务端渲染的内容，通过插槽穿透客户端组件
```

### 类比

```
直接调用 = 堂食
- 餐厅（Parent）负责做菜（渲染 Child）
- 你点什么，餐厅就做什么
- 餐厅关门（Parent 卸载），你就吃不到了

插槽传递 = 外卖
- 你在家（外部）点好菜（渲染 Child）
- 餐厅（Parent）只是把菜放到桌上（展示 children）
- 餐厅换装修（Parent 更新），你的菜不受影响
```

## 总结

| 方式                     | 语法                                 | 适用场景                     |
| ------------------------ | ------------------------------------ | ---------------------------- |
| **children prop**        | `<Parent><Child /></Parent>`         | 最常用，单个内容区域         |
| **具名插槽**             | `<Layout header={<Header />} />`     | 多个明确的插槽位置           |
| **Render Props**         | `<Fetcher render={(data) => ...} />` | 需要传递数据给子组件         |
| **Function as Children** | `<Tracker>{(pos) => ...}</Tracker>`  | Render Props 的简化版        |
| **组件作为 Props**       | `<Button icon={Icon} />`             | 传递组件类型，父组件控制渲染 |
| **cloneElement**         | `React.cloneElement(child, props)`   | 需要修改子组件的 props       |

**核心原则**：

- 简单场景用直接调用
- 复杂场景用插槽传递
- 需要性能优化用插槽传递
- Next.js 混合架构必须用插槽传递
